---
title: Randomness
description: Describes how you can introduce randomness in a Substrate runtime.
keywords:
---

Because blockchains require deterministic outcomes—where the same input always produces the same output—finding an appropriate source to produce seemingly random results presents a unique challenge.
However, there are many applications where randomness can be essential to performing certain operations.
For example, you want to include randomness to select the validator responsible for producing a block to prevent validator selection from being predictable, and thereby vulnerable to be exploited in an attack.
You might also use randomness in statistical or scientific analyses, in cryptographic operations, or in applications involving gaming or gambling.

## Deterministic randomness

In traditional computer applications, what people call random numbers are actually generated using **pseudo-randomness**.
Pseudo-randomness depends on a sufficiently random seed—provided by the user or by an external source—and an algorithm that manipulates the seed to generate a series of seemingly-random numbers. 
The result is a pseudo-random number that is difficult to predict because of the algorithm used to generate it, but deterministic because the same seed input always produces the same series of output.

However, applications that run on the blockchain are more tightly constrained because all authorities in the network must agree on any on-chain value, including any randomness data that is injected.
Because of this constraint, you can't use real randomness directly in blockchain applications.

For blockchain applications, the most common approach to providing randomness is a cryptographic primitive called a[verifiable random function](https://en.wikipedia.org/wiki/Verifiable_random_function).
A verifiable random function (VRF) is a mathematical operation that takes input and produces a random number and a proof of authenticity that this random number was generated by the submitter. 
The proof can be verified by any challenger to ensure that the random number generation is valid.

In the Polkadot ecosystem and Substrate-based chains, verifiable random functions are part of the consensus mechanism provided by the BABE pallet. For more information about the relationship between verifiable random functions and consensus, see [Consensus](/fundamentals/consensus/)

## Randomness trait in Substrate

Substrate provides a trait called [`Randomness`](https://paritytech.github.io/substrate/master/frame_support/traits/trait.Randomness.html) that codifies the interface between the logic that generates randomness and the logic that consumes it.
This trait allows the two pieces of logic to be written independently of each other.

### Consuming randomness

A developer who is writing a pallet that needs randomness, does not need to worry about providing that randomness.
Rather, the pallet can simply require a randomness source that implements the trait.
The `Randomness` Trait provides two methods for gaining randomness.

The first method is called `random_seed`.
It takes no parameters and gives back a raw piece of randomness.
Calling this method multiple times in a block will return the same value each time.
Thus, it is not recommended to use this method directly.

The second method is called `random`.
It takes a byte-array which is used as a context identifier and returns a result as unique to this context and as independently from other contexts as allowed by the underlying randomness source.

### Generating randomness

There are many different ways to implement the `Randomness` trait.
You can implement the trait many different ways, depending on the security guarantees and performance trade-offs that your application requires.
Substrate ships with two implementations that provide different trade-offs between performance, complexity, and security.

The first implementation provided by Substrate is the [insecure randomness](https://paritytech.github.io/substrate/master/pallet_insecure_randomness_collective_flip/index.html) pallet.
This pallet provides a `random` function that generates pseudo-random values based on the block hashes from the previous 81 blocks. 
This type of randomness performs well but isn't secure.
You should only use this pallet in applications with low security requirements or when testing randomness-consuming applications.
You shouldn't use this pallet in a production environment.

The second implementation is in the [BABE pallet](https://paritytech.github.io/substrate/master/pallet_babe/index.html)and uses verifiable random functions.
This pallet provides production-grade randomness, and is used in Polkadot.
Selecting this randomness source dictates that your blockchain use Babe consensus.

## Security properties

The `Randomness` trait provides a convenient and useful abstraction over randomness sources in Substrate runtimes.
But the trait itself does not make any security guarantees.
A runtime developer must ensure that the randomness source used meets the security requirements of _all_ pallets that consume its randomness.

## Where to go next

- [How-to: Randomness](/reference/how-to-guides/pallet-design/incorporate-randomness/)
- [`Randomness`](https://paritytech.github.io/substrate/master/frame_support/traits/trait.Randomness.html)
