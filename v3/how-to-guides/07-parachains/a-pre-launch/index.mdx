---
title: Parachain Pre-Launch Requirements
slug: /how-to-guides/v3/parachains/pre-launch
version: 3.0
section: how to guides
category: parachains
difficulty: 2
keywords: [collator, parachain, launch, prereq, requirements, checklist, weight, migration]
---

<Objectives
  data={[
    {
      title: 'Goal',
      description: `
	    - Ensure \`protocolId\` is set uniquely.
		- Ensure runtime weights are correct.
		`,
    },
    {
      title: 'Use Cases',
      description: `
        - Launching a parachain outside of a local testing environment.
      `,
    },
    {
      title: 'Overview',
      description: `
        The runtime constraints on a parachain are _much_ stricter than a solochain, as you _must_
        coordinate with the relay chain to finalize state transitions. When launching a parachain to
        production, it is critically important to make sure a chain's runtime is properly configured
        and tested.
		\n
		**Before you continue**, please read about:
		- [Benchmarking](/v3/runtime/benchmarking) 
		- [Memory profiling](/v3/tools/memory-profiling) and complete the
        [cumulus tutorial](/tutorials/v3/cumulus/start-relay) (you want a good understanding of the
        \`polkadot-launch\` tool to enable dummy chain testing)
      `,
    },
  ]}
/>

## Steps

### 1. Set a unique `protocolId`

_All_ chains should use a **unique** `protocolId`. This ensures nodes do not incorrectly connect to
nodes from other libp2p networks (like other chains' nodes) isolate themselves and guard against
from peering in a way that will cause _many_ issues.

In order to set a unique ProtocolID, change make sure you use some nonce or salt value. This is set
(for
the <ExternalLink url="https://github.com/substrate-developer-hub/substrate-parachain-template/"> parachain node template </ExternalLink>
as a CLI item in `/client/network/src/command.rs`, and passed to extend the `/client/network/src/chain_spec.rs`

```rust
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct ProtocolId(smallvec::SmallVec<[u8; 6]>);

impl<'a> From<&'a str> for ProtocolId {
	fn from(bytes: &'a str) -> ProtocolId {
		ProtocolId(bytes.as_bytes().into())
	}
}
```	

This step is important &mdash; you wouldn't want to connect to the wrong network!

<Message
  type={`green`}
  title={`Tip`}
  text={`Refer to [this guide](./pallet-design/randomness) for some ideas on creating a unique value to use here.`}
/>

<Message
  type={`gray`}
  title={`A note on Memory Profiling`}
  text={`[Profiling your collator](/v3/tools/memory-profiling) should be done to analyze memory leaks,
	identify where memory consumption is happening, define temporary
	allocations, and investigate excessive memory fragmentation within
	applications.
  `}
/>



<Message
  type={`gray`}
  title={`A note on Memory Profiling`}
  text={`
         Keep an eye (subscribe)
        to <ExternalLink url="https://github.com/paritytech/substrate/issues/7746"> this issue </ExternalLink> 
        that will address a better method to safely configure this constant in the future.
  `}
/>


### 2. Check runtime weights

Use benchmarking to verify that your runtime weights are correct.

<Message
  type={`green`}
  title={`Tip`}
  text={`Refer to this [article](/v3/runtime/benchmarking) on benchmarking for additional information.`}
/>

#### Customize weights

Make sure that each pallet in your runtime employs the correct weighting system. Default Substrate
weight **are not** to be used in production, as a general rule.

#### Set block weight limit

It is recommended to have a block weight limit (block production time) of 0.5 seconds in the
beginning due to uncertainties in block execution time. As the execution time of the network
stabilizes the weight limit can be increased to 2 seconds.

### 3. Runtime deployment

#### Minimize the size of your runtime

Generally, when launching a parachain, it is important to use the **compressed version of the
runtime** to lower the amount of data being transferred.

- It is recommended to launch a parachain with limited functionality and gradually increase it with
  runtime upgrades. The reason behind that is that during a runtime upgrade both the previous runtime
  and the new runtime are included in the PoVBlock and therefore if the changes are large enough the
  block might be rejected by the Relay Chain due to PoVBlock size limits.

- If the runtime is included in the state proof, ensure the PoV block (i.e. the set of extrinsics,
  including the new runtime, the PoV state proof, potentially the old runtime) fits within the
  PoVBlock size limit. If the runtime is not included in the state proof, the size limit of the new
  runtime will be much higher.

<Message
  type={`gray`}
  title={`Memory profiling to comply with relay chain`}
  text={`You can check the maximum sizes [in the Polkadot
         repo](https://github.com/paritytech/polkadot/blob/master/primitives/src/v1/mod.rs#L247-L253)
         for all relay chains (these are common constants). Make note of:
		 - The runtime version of the relay chain you are targeting (these _may_ change)
         - \`MAX_CODE_SIZE\`
         - \`MAX_HEAD_DATA_SIZE\`
         - \`MAX_POV_SIZE\`
		 You **must** have your parachain fit comfortably within these maxima.
         You can also use the the Polkadot-JS Apps UI connected to a relay node to see these
         constants: _Developers_ -> _ParachainsConfiguration_ -> _ActiveConfiguration_
  `}
/>

<Message
  type={`yellow`}
  title={`Information`}
  text={`Here you can see an example of how to [limit](https://github.com/paritytech/cumulus/blob/59cdbb6a56b1c49009413d66ba2232494563b57c/polkadot-parachains/statemine/src/lib.rs#L148) 
  nd [enable](https://github.com/paritytech/cumulus/pull/476/files#diff-09b95657e9aa1b646722afa7944a00ddc2541e8753254a86180b338d3376f93eL151) 
  functionality with filters as implemented in [Statemint](https://github.com/paritytech/cumulus/tree/master/polkadot-parachains/statemint).`}
/>

#### For large runtimes

It is less favorable to perform storage upgrades for large runtimes. In these cases, you can:

1. Generate the genesis state of your chain with full runtime functionality (including all the pallets)

2. Remove all pallets that you will not need upon parachain launch from your runtime

3. Re-build the WASM blob (validation logic) and the runtime of the chain

4. Register your parachain with the updated genesis and the WASM blob generated in (3)

5. After your parachain is live you can upgrade your runtime on-chain to include the missing pallets (ensure that pallet indices and names match those used to generate the genesis state in step (1) without having to do storage migrations. For more information on on-chain runtime upgrades refer to the next section.

## Examples

- [Statemine runtime deployment](https://github.com/paritytech/cumulus/pull/476)

## Resources

#### Docs

- [Benchmarking][benchmarking-kb]

[benchmarking-kb]: /v3/runtime/benchmarking
