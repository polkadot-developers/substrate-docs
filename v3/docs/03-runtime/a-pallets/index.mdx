---
title: Pallets
slug: /v3/runtime/pallets
version: 3.0 
section: docs
category: runtime
keywords:
---

The following documentation is written for technical audiences, familiar with the Rust programming
language. It is a top-level entry point for FRAME runtime developement in Substrate.

<Message
  type={`green`}
  title={`Tip`}
  text={`If you are just getting started with Substrate runtime development, we suggest you try
  our introductory tutorial for
  [creating your first Substrate chain](/tutorials/v3/create-your-first-substrate-chain).`}
/>

## What is a Pallet?

Pallets are a special kind of Rust module made up of a set of types, trait implementations and functions
from which Substrate runtimes can be composed. FRAME not only
provides a library of commonly used Substrate pallets but also a framework to build custom domain-specific
pallets, giving runtime engineers the flexibility to define their runtime's behaviour according to their
target use case. The result: each pallet has its own discrete logic which can modify the features and
functionality of your blockchain's state transition functions.

For example, the [Balances pallet](https://github.com/paritytech/substrate/tree/master/frame/balances), which is included in [FRAME](../frame), defines cryptocurrency capabilities for your blockchain. More specifically, it
defines:

- **Storage items** that keep track of the tokens a user owns.
- **Functions** that users can call to transfer
  and manage those tokens.
- **APIs** which allow other pallets to make use of those tokens and their capabilities.
- **Hooks**
  which allow other pallets to trigger function calls when a user's balance changes.

Substrate runtime engineers can define custom logic for their blockchain by writing their own pallets and encapsulating their blockchains desired functionality by combining custom pallets with existing FRAME pallets or Substrate modules alike. The following documentation will show you how.

<Message
  type={`gray`}
  title={`Note`}
  text={`At the time of writing, FRAME pallets exist in two different flavors &mdash; Version 1 and Version 2. This article first covers the structure of a v1 pallet. Skip to [FRAME v2](#frame-v2) for the latest structure of a Substrate pallet. Read [here](../macros#frame-v1-vs-v2) for more information on these changes.`}
/>

## Skeleton of a Pallet

A FRAME pallet is composed of 7 sections:

```rust
// 1. Imports and Dependencies
pub use pallet::*;
#[frame_support::pallet]
pub mod pallet {
	use frame_support::pallet_prelude::*;
	use frame_system::pallet_prelude::*;
}

// 2. Declaration of the Pallet type
// This is a placeholder to implement traits and methods.
#[pallet::pallet]
#[pallet::generate_store(pub(super) trait Store)]
	pub struct Pallet<T>(PhantomData<T>);

// 3. Runtime Configuration Trait
// All types and constants go here.
// Use #[pallet::constant] and #[pallet::extra_constants]
// to pass in values to metadata.
#[pallet::config]
	pub trait Config: frame_system::Config { ... }

// 4. Runtime Storage
// Use to declare storage items.
#[pallet::storage]
	#[pallet::getter(fn something)]
	pub MyStorage<T: Config> = StorageValue<_, u32>;

// 5. Runtime Events
// Can stringify event types to metadata.
#[pallet::event]
	#[pallet::metadata(T::AccountId = "AccountId")]
	#[pallet::generate_deposit(pub(super) fn deposit_event)]
	pub enum Event<T: Config> { ... }

// 6. Hooks
// Define some logic that should be executed
// regularly in some context, for e.g. on_initialize.
#[pallet::hooks]
	impl<T: Config> Hooks<BlockNumberFor<T>> for Pallet<T> { ... }

// 7. Extrinsics
// Functions that are callable from outside the runtime.
#[pallet::call]
	impl<T:Config> Pallet<T> { ... }

```

<Message
  type={`gray`}
  title={`Note`}
  text={`Pallets can be composed of as many sections as needed, giving runtime engineers a lot of 
  flexibility ontop of the basic skeletons depicted above. Refer to the [Substrate Runtime Macros](../macros#substrate-runtime-macros)
  to learn more about adding functionality to a FRAME pallet.`}
/>
