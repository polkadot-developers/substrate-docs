---
title: Implement the Contracts pallet and its APIs
slug: /tutorials/v3/add-contracts/pt2
version: 3.0 
section: tutorials
category: contracts
keywords: smart contracts, wasm
---

## Overview

In the previous part, we've successfully imported the Contracts pallet crate. In this part
we will add the pallet to our runtime, implementing a custom API and outer node requirements.

In this section you will learn how to:
- Implement the requirements for the Contracts pallet
- Implement a custom runtime API for the contracts pallet
- Implement the Contract pallet's RPC API extension

## Steps 

### 1. Implementing the Contract Trait

Every pallet has a configuration trait called `Config` that the runtime must implement.

To figure out what we need to implement for this pallet specifically, you can take a look at the
FRAME [`pallet_contracts::Config` documentation](/rustdocs/latest/pallet_contracts/trait.Config.html).

For our runtime, the implementation will look like this:

**`runtime/src/lib.rs`**

```rust
use pallet_transaction_payment::CurrencyAdapter;
   /* --snip-- */

/*** Add This Line ***/
use pallet_contracts::weights::WeightInfo;
```
```rust

// These time units are defined in number of blocks.
   /* --snip-- */

/*** Add This Block ***/
// Contracts price units.
pub const MILLICENTS: Balance = 1_000_000_000;
pub const CENTS: Balance = 1_000 * MILLICENTS;
pub const DOLLARS: Balance = 100 * CENTS;

const fn deposit(items: u32, bytes: u32) -> Balance {
   items as Balance * 15 * CENTS + (bytes as Balance) * 6 * CENTS
}

/// We assume that ~10% of the block weight is consumed by `on_initialize` handlers.
/// This is used to limit the maximal weight of a single extrinsic.
const AVERAGE_ON_INITIALIZE_RATIO: Perbill = Perbill::from_percent(10);

/*** End Added Block ***/
```

```rust

impl pallet_timestamp::Config for Runtime {
   /* --snip-- */
}

/*** Add This Block ***/
parameter_types! {
   pub TombstoneDeposit: Balance = deposit(
      1,
      <pallet_contracts::Pallet<Runtime>>::contract_info_size()
   );
   pub DepositPerContract: Balance = TombstoneDeposit::get();
   pub const DepositPerStorageByte: Balance = deposit(0, 1);
   pub const DepositPerStorageItem: Balance = deposit(1, 0);
   pub RentFraction: Perbill = Perbill::from_rational(1u32, 30 * DAYS);
   pub const SurchargeReward: Balance = 150 * MILLICENTS;
   pub const SignedClaimHandicap: u32 = 2;
   pub const MaxValueSize: u32 = 16 * 1024;
   // The lazy deletion runs inside on_initialize.
   pub DeletionWeightLimit: Weight = AVERAGE_ON_INITIALIZE_RATIO *
      BlockWeights::get().max_block;
   // The weight needed for decoding the queue should be less or equal than a fifth
   // of the overall weight dedicated to the lazy deletion.
   pub DeletionQueueDepth: u32 = ((DeletionWeightLimit::get() / (
         <Runtime as pallet_contracts::Config>::WeightInfo::on_initialize_per_queue_item(1) -
         <Runtime as pallet_contracts::Config>::WeightInfo::on_initialize_per_queue_item(0)
      )) / 5) as u32;

   pub Schedule: pallet_contracts::Schedule<Runtime> = Default::default();
}

impl pallet_contracts::Config for Runtime {
   type Time = Timestamp;
   type Randomness = RandomnessCollectiveFlip;
   type Currency = Balances;
   type Event = Event;
   type RentPayment = ();
   type SignedClaimHandicap = SignedClaimHandicap;
   type TombstoneDeposit = TombstoneDeposit;
   type DepositPerContract = DepositPerContract;
   type DepositPerStorageByte = DepositPerStorageByte;
   type DepositPerStorageItem = DepositPerStorageItem;
   type RentFraction = RentFraction;
   type SurchargeReward = SurchargeReward;
   type WeightPrice = pallet_transaction_payment::Module<Self>;
   type WeightInfo = pallet_contracts::weights::SubstrateWeight<Self>;
   type ChainExtension = ();
   type DeletionQueueDepth = DeletionQueueDepth;
   type DeletionWeightLimit = DeletionWeightLimit;
   type Call = Call;
	/// The safest default is to allow no calls at all.
	///
	/// Runtimes should whitelist dispatchables that are allowed to be called from contracts
	/// and make sure they are stable. Dispatchables exposed to contracts are not allowed to
	/// change because that would break already deployed contracts. The `Call` structure itself
	/// is not allowed to change the indices of existing pallets, too.
	type CallFilter = DenyAll;
	type Schedule = Schedule;
	type CallStack = [pallet_contracts::Frame<Self>; 31];
}
/*** End Added Block ***/
```

At this point, it is recommended to explore the
[Contracts pallet source code](https://github.com/paritytech/substrate/blob/v3.0.0/frame/contracts/src/lib.rs)
if things don't make sense or you want to gain a deeper understanding.

### 2. Adding Contracts to the `construct_runtime!` Macro

Next, we need to add the pallet to the `construct_runtime!` macro. For this, we need to determine
the types that the pallet exposes so that we can tell our runtime that they exist. The complete
list of possible types can be found in the
[`construct_runtime!` macro documentation](/rustdocs/latest/frame_support/macro.construct_runtime.html).

If we look at the Contracts pallet in detail, we know it has:

- Module **Storage**: Because it uses the `decl_storage!` macro.
- Module **Event**: Because it uses the `decl_event!` macro.
- **Call**able Functions: Because it has dispatchable functions in the `decl_module!` macro.
- **Config**uration Values: Because the `decl_storage!` macro has `config()` parameters.
- The **Module** type from the `decl_module!` macro.

Thus, when we add the pallet, it will look like this:

**`runtime/src/lib.rs`**

```rust
construct_runtime!(
   pub enum Runtime where
      Block = Block,
      NodeBlock = opaque::Block,
      UncheckedExtrinsic = UncheckedExtrinsic
   {
      /* --snip-- */

      /*** Add This Line ***/
      Contracts: pallet_contracts::{Pallet, Call, Storage, Event<T>},
   }
);
```

Note that not all pallets will expose all of these runtime types, and some may expose more than just these! Always look at the source code of a pallet or the documentation of the pallet you're using to determine which of
these types you need to expose.

This is another good time to check that your runtime compiles correctly so far. Although the runtime
should compile, the entire node will not (yet). So we will use this command to just check the
runtime only:

```bash
cargo check -p node-template-runtime
```
### 3. Exposing The Contracts API

Some pallets, including the Contracts pallet, expose custom runtime APIs and RPC endpoints. In the
case of the Contracts pallet, this enables reading contracts state from off chain.

It's not required to enable the RPC calls on the Contracts pallet to use it in our chain. However,
we'll do it to make calls to our node's storage without making a transaction.

We start by adding the required API dependencies in our `Cargo.toml`.

**`runtime/Cargo.toml`**

```TOML
[dependencies.pallet-contracts-rpc-runtime-api]
default-features = false
git = 'https://github.com/paritytech/substrate.git'
tag = 'monthly-2021-08'
version = '4.0.0-dev'
```

**`runtime/Cargo.toml`**

```TOML
[features]
default = ['std']
std = [
   #--snip--
   'pallet-contracts-rpc-runtime-api/std',
]
```

To get the state of a contract variable, we have to call a getter function that will return a
`ContractExecResult` wrapper with the current state of the execution.

**`runtime/src/lib.rs`**

We're now ready to implement the contracts runtime API. This happens in the `impl_runtime_apis!`
macro near the end of your runtime.

```rust
impl_runtime_apis! {
   /* --snip-- */

   /*** Add This Block ***/
   impl pallet_contracts_rpc_runtime_api::ContractsApi<Block, AccountId, Balance, BlockNumber, Hash>
   for Runtime
   {
      fn call(
         origin: AccountId,
         dest: AccountId,
         value: Balance,
         gas_limit: u64,
         input_data: Vec<u8>,
      ) -> pallet_contracts_primitives::ContractExecResult {
         let debug = true;
         Contracts::bare_call(origin, dest, value, gas_limit, input_data, debug)
      }

      fn instantiate(
         origin: AccountId,
         endowment: Balance,
         gas_limit: u64,
         code: pallet_contracts_primitives::Code<Hash>,
         data: Vec<u8>,
         salt: Vec<u8>,
      ) -> pallet_contracts_primitives::ContractInstantiateResult<AccountId, BlockNumber> {
         let compute_rent_projection = true;
         let debug = true;
         Contracts::bare_instantiate(origin, endowment, gas_limit, code, data, salt, compute_rent_projection, debug)
      }

      fn get_storage(
         address: AccountId,
         key: [u8; 32],
      ) -> pallet_contracts_primitives::GetStorageResult {
         Contracts::get_storage(address, key)
      }

      fn rent_projection(
         address: AccountId,
      ) -> pallet_contracts_primitives::RentProjectionResult<BlockNumber> {
         Contracts::rent_projection(address)
      }
   }
   /*** End Added Block ***/
}
```

This is another good time to check that your runtime compiles correctly so far.

```bash
cargo check -p node-template-runtime
```

### 4. Updating the Outer Node

At this point we have finished adding a pallet to the runtime. We now turn our attention to the
outer node which will often need some corresponding updates. In the case of the Contracts pallet we
will add the custom RPC endpoint and a genesis configuration.

#### Adding the RPC API extension

With the proper runtime API exposed, now we can add the RPC to the node's service to call into that
runtime API. Because we are now working in the outer node, we are not building to `no_std` and we
don't have to maintain a dedicated `std` feature.

**`node/Cargo.toml`**

```toml
[dependencies]
jsonrpc-core = '15.1.0'
structopt = '0.3.8'
#--snip--
# *** Add the following lines ***
[dependencies.pallet-contracts]
git = 'https://github.com/paritytech/substrate.git'
tag = 'monthly-2021-08'
version = '4.0.0-dev'

[dependencies.pallet-contracts-rpc]
git = 'https://github.com/paritytech/substrate.git'
tag = 'monthly-2021-08'
version = '4.0.0-dev'
```


Substrate provides an RPC to interact with our node. However, it does not contain access to the
Contracts pallet by default. To interact with this pallet, we have to extend the existing RPC and
add the Contracts pallet along with its API.

**`node/src/rpc.rs`**

```rust
use node_template_runtime::{opaque::Block, AccountId, Balance, Index, BlockNumber, Hash}; // NOTE THIS IS AN ADJUSTMENT TO AN EXISTING LINE
use pallet_contracts_rpc::{Contracts, ContractsApi};
```

```rust
/// Instantiate all full RPC extensions.
pub fn create_full<C, P>(
   deps: FullDeps<C, P>,
) -> jsonrpc_core::IoHandler<sc_rpc::Metadata> where
   /* --snip-- */
   C: Send + Sync + 'static,
   C::Api: substrate_frame_rpc_system::AccountNonceApi<Block, AccountId, Index>,
   /*** Add This Line ***/
   C::Api: pallet_contracts_rpc::ContractsRuntimeApi<Block, AccountId, Balance, BlockNumber, Hash>,
   /* --snip-- */
{
   /* --snip-- */
   io.extend_with(
      TransactionPaymentApi::to_delegate(TransactionPayment::new(client.clone()))
   );
   /*** Add This Block ***/
   // Contracts RPC API extension
   io.extend_with(
      ContractsApi::to_delegate(Contracts::new(client.clone()))
   );
   /*** End Added Block ***/
   io
}
```
<Message
  type={`gray`}
  title={`RPC additions must appear with the following syntax:`}
  text={` 
  \`io.extend_with(YourRpcTrait::to_delegate(YourRpcStruct::new(ReferenceToClient, ...)));\`
  
  where \`YourRpcStruct\` should have a reference to a client, which is needed to call into the runtime.`}
/> 

### 5. Start Your Upgraded Chain

Now you are ready to compile and run your contract-capable node. Compile the node in release mode
using:

```bash
cargo build --release
```

Now launch the executable you just built by running this command

```bash
# Run a temporary node in development mode
./target/release/node-template --dev --tmp
```

### 6. Adding Other FRAME pallets

In this guide, we walked through specifically how to import the Contracts pallet, but as mentioned
in the beginning of this guide, each pallet will be a little different. Have no fear, you can always
refer to the [demonstration Substrate node runtime](https://github.com/paritytech/substrate/tree/v3.0.0/bin/node/runtime) which includes nearly every pallet in FRAME.

In the `Cargo.toml` file of the Substrate node runtime, you will see an example of how to import
each of the different pallets, and in the `lib.rs` file you will find how to add each pallet to your
runtime. You can basically copy what was done there to your own runtime.

## Next steps
### Learn More

- [A minimalist tutorial on writing your runtime pallet in its own package](/tutorials/v3/proof-of-existence/pallet).
- With your node now capable of running smart contracts, go learn about
  [Substrate ink! smart contracts](/docs/v3/smart-contracts/overview).
- [Substrate Recipes](https://substrate.dev/recipes/) offers detailed tutorials about writing
  [Runtime APIs](https://substrate.dev/recipes/runtime-api.html) and
  [Custom RPCs](https://substrate.dev/recipes/custom-rpc.html) like the ones explored in
  this tutorial.
- Understand the [Chain Spec](/docs/v3/toolchains/chain-specs) file to customize your Genesis
  Configuration.

### References

- [FRAME `Contracts` Pallet API](/rustdocs/latest/pallet_contracts/index.html)

