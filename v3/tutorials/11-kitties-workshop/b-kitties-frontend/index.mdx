---
title: Kitties Workshop
slug: /tutorials/v3/kitties/pt2
version: 3.0
section: Tutorials
category: FRAME
keywords: nft, kitties, frontend 
difficulty: 2
duration: 2 Hours
relevantSkills: 
  - Javascript
  - React
---

## Introduction

In Part 1 we created all of the back-end portion of our Kitties application. In this part, it's time to 
build a user interface which can access and interact with our
custom storage items and functions. We'll be using the Front-end Template, a React app with some basic functionality, and the
Polkadot JS API to make RPC's to our chain's runtime.

In Part 2, there will only be two main sections: the first focussing on setting up the Front-end Template and the second 
focussing on building custom React components that can interact with our kitty-node.

We'll be using a [library for generating Cat avatars](https://framagit.org/Deevad/cat-avatar-generator), licensed under [CC-By 4.0](https://creativecommons.org/licenses/by/4.0/) attribution. Thank you [David Revoy's](https://framagit.org/Deevad) for making this available.

### Learning outcomes

- Connect your chain to the Substrate front-end template.
- Use PolkadotJS API to create custom React components.

## Getting Started 

The first step of this tutorial is to familiarize yourself with the Substrate Front-end template. In this step we will go through an overview of what our React app will look like and the different components we'll be building. 

Start by [installing the Front-end Template][substrate-frontend-template]:

```bash
git clone https://github.com/substrate-developer-hub/substrate-front-end-template.git
cd substrate-front-end-template
yarn install
```

You'll notice the following structure (we've only including the directories we care about for this tutorial):

```
substrate-front-end-template
|
...
|
+-- public
|   |
|   +-- assets              <-- Kitty avatar PNG files
|
+-- src                     <-- our React components
|   |
|   +-- __tests__
|   |
|   +-- config              <-- where to specify our custom types
|   |
|   +-- substrate-lib       <-- lib to give access to PolkadotJS API 
|   |   |
|   |   +-- components      <-- contains TxButton, used throughout our application
|   |
|   AccountSelector.js
|   App.js
|   Balances.js
|   BlockNumber.js
|   Events.js
|   index.js
|   interactor.js
|   Metadata.js
|   NodeInfo.js
|   TemplateModule.js
|   Transfer.js
|   Upgrade.js
|
...
```

In a separate terminal, start an instance of `node-kitties` that you built in Part 1:

```bash
# Launch `node-kitties` from its directory.
cd kitties/
./target/release/node-kitties --dev --tmp
```

Now, in the same directory as where you installed the Front-end template, launch it:

```bash
yarn start
```

You should see a tab open up with the front-end template displaying basic features of your chain.

Notice that it comes with a number of prebuilt features, each being rendered by the provided components of the Front-end Template.

### Specifying Types

An important starting point when setting up a custom front-end for a Substrate node is creating a JSON file with all
of the node's custom types. These are types that we created in our pallet that the Polkadot JS API doesn't know about.
Learn more about [Extending types](https://polkadot.js.org/docs/api/start/types.extend/) in the Polkadot JS API documentation.

In our case, we have two custom types we'll need to add: the `Gender` enum and the `Kitty` struct.

To do this, go into `src/config/types.json` and paste in the following lines:

```json
{
  "Gender": {
    "_enum": ["Male", "Female"]
  },
  "Kitty": {
    "dna": "[u8; 16]",
    "price": "Option<Balance>",
    "gender": "Gender",
    "owner": "AccountId"
  }
}
```

### Sketching out our application components

[Substrate Frontend Template][substrate-frontend-template] components use PolkadotJS Apps and an 
RPC endpoint to communicate with a Substrate node. This allows us to use it
to read storage items, and pass in inputs to allows users to make extrinsics by calling our pallet's
dispatchable functions. Before we get to that, let's sketch out the different parts of our application.

We'll be building out a total of 3 components:

1. `KittyCards.js`: this will render a React card component containing a Kitty's relevant information, avatar and buttons to interact with it.
2. `KittyAvatar.js`: this will handle the logic to map Kitty DNA to the library of PNGs we're using to create unique Kitty avatars.
3. `Kitties.js`: this will be what we render to `App.js`.

### Polkadot JS API basics

Before moving on to the next section, we reccommend you read a little Polkadot JS API documentation to understand the basics of 
how we'll be querying storage and triggering transactions. Here are some good resources:

- [Basics and Metadata](https://polkadot.js.org/docs/api/start/basics)
- [RPC queries](https://polkadot.js.org/docs/api/start/api.rpc)
- [Storage methods](https://polkadot.js.org/docs/substrate/storage) such as `api.query.<module>.<method>` to access a pallet instance in a runtime
- [Extrinsics methods](https://polkadot.js.org/docs/substrate/extrinsics) such as `api.tx.<module>.<method>` to trigger a transaction.

### Next steps

- Build the Kitties.js component
- Build the KittyAvatar.js component
- Build the KittyCards.js Component

[substrate-frontend-template]: https://github.com/substrate-developer-hub/substrate-front-end-template

## Creating Custom Components

In this section, we are going to build the custom components of our Kitty application's front-end.

To recap, these are:

- **the `Kitties.js` component:** this renders KittyCards.js 
- **the `KittyAvatar.js` component:** this handles the logic that creates an avatar for a Kitty in storage
- **the `KittyCards.js` component:** this creates a React  `<Card/>` component to hold Kitty ID, gender, DNA, owner and price

### Create the `Kitties.js` component

This is the component that will get rendered by Apps.js. So it does the heavy lifting, with the help of KittyAvatar.js and KittCards.js.

Start by creating a file called `Kitties.js` and paste the following imports:

```js
import React, { useEffect, useState } from 'react';
import { Form, Grid } from 'semantic-ui-react';

import { useSubstrate } from './substrate-lib';
import { TxButton } from './substrate-lib/components';

import KittyCards from './KittyCards';
```

The way our custom components will make use of PolkadotJS API is by using `substrate-lib`, which is a wrapper around [Polkadot JS API instance](https://polkadot.js.org/docs/api/start/create/) and allows us to retrieve the API from the [PolkadotJS keyring](https://polkadot.js.org/docs/api/start/keyring). This is why we use `useSubstrate` which is exported by `src/substrate-lib/SubstrateContext.js` and used to create the wrapper.

Then, there's a couple things to set up:

- we'll need a function to help construct the Kitty ID from a storage key
- we'll need a function to hold a Kitty object 
- we'll rely on `useEffect` from `import React, { useEffect, useState } from 'react';` to listen for changes in our node's storage using React hooks

Proceed by pasting in the following code snippet:

```js
// Construct a Kitty ID from storage key
const convertToKittyHash = entry =>
  `0x${entry[0].toJSON().slice(-64)}`;

// Construct a Kitty object 
const constructKitty = (hash, { dna, price, gender, owner }) => ({
  id: hash,
  dna,
  price: price.toJSON(),
  gender: gender.toJSON(),
  owner: owner.toJSON()
});

// Use React hooks
export default function Kitties (props) {
  const { api, keyring } = useSubstrate();
  const { accountPair } = props;

  const [kittyHashes, setKittyHashes] = useState([]);
  const [kitties, setKitties] = useState([]);
  const [status, setStatus] = useState('');
// snip
```
There are two things our app needs to listen for: changes in the amount of Kitties and changes in the Kitty object. To do this we'll create a subscription function for each.

The way we're going to listen for a change in the amount of Kitties is by querying our node using `api.query.kitties.kittyCnt`, which
queries `KittyCnt` from our Kitties pallet storage item. Then, we'll use the `entries()` method from PolkadotJS API to construct a Kitty
ID using the `convertToKittyHash` function.

Paste the following snippet:

```js
// Subscription function for setting Kitty IDs
  const subscribeKittyCnt = () => {
    let unsub = null;

    const asyncFetch = async () => {
        // Query KittyCnt from runtime
      unsub = await api.query.kitties.kittyCnt(async cnt => {
        // Fetch all Kitty objects using entries()
        const entries = await api.query.kitties.kitties.entries();
        // Retrieve only the Kitty ID and set to state
        const hashes = entries.map(convertToKittyHash);
        setKittyHashes(hashes);
      });
    };

    asyncFetch();

    // return the unsubscription cleanup function
    return () => {
      unsub && unsub();
    };
  };
```

<Message
  type={`green`}
  title={`Further Learning `}
  text={`\`entries()\` is a Polkadot JS API function that gives us the entire storage map. If there's nothing in storage, it passes in \`None\` which acts
    as a promise to React hooks. With \`entries()\` we get a key and a kitty object.
    You can see this in action if you go to the console of your browser running a node Front-end and entering \`entries\`. 
    Or get the first Kitty object in storage by doing: \`entries[0][1].toJSON()\`.`}
/>

Similarly for `subscribeKitties`, paste the following code snippet:

```js
  // Subscription function to construct a Kitty object
  const subscribeKitties = () => {
    let unsub = null;

    const asyncFetch = async () => {
        // Get Kitty objects from storage 
      unsub = await api.query.kitties.kitties.multi(kittyHashes, kitties => {
        // Create an array of Kitty objects from `constructKitty`
        const kittyArr = kitties
          .map((kitty, ind) => constructKitty(kittyHashes[ind], kitty.value));
        // Set the array of Kitty objects to state
        setKitties(kittyArr);
      });
    };

    asyncFetch();

    // return the unsubscription cleanup function
    return () => {
      unsub && unsub();
    };
  };
```

#### Understanding how we retrieve the Kitty Hash

The PolkadotJS API uses the pallet name and storgae item for the first 64 bits and the unique storage item hash for the remaining 64 bits. We want to get rid of those and only keep the remaining bits which will be our kitty Hash, which is why we use:

```js
const convertToKittyHash = entry =>
  `0x${entry[0].toJSON().slice(-64)}`;
```

And then we use it in the subscription function to get all Kitty IDs:

```js
   const asyncFetch = async () => {
      unsub = await api.query.kitties.kittyCnt(async cnt => {
        // Fetch all kitty keys
        const entries = await api.query.kitties.kitties.entries();
        const hashes = entries.map(convertToKittyHash);
        setKittyHashes(hashes);
      });
    };
```

#### Clean up functions

In `asyncFetch` we're constantly listening to the Kitties storage. This is in relation to using Effects with Cleanup (see [React docs])https://reactjs.org/docs/hooks-effect.html#effects-with-cleanup)). When the component is teared down, it will make sure that all remaining subscription functions are cleaned up:

```js
  // return the unsubscription cleanup function
    return () => {
      unsub && unsub();
    };
  };
```
Now all that's left to do for our component to listen for changes in our node's runtime storgae is to pass in `subscribeKittyCnt` and 
`subscribeKitties` to React's `useEffect` function. Hence: 

```js
  useEffect(subscribeKittyCnt, [api, keyring]);
  useEffect(subscribeKitties, [api, kittyHashes]);
```

Learn more about how "Effect Hooks" work in [React's documentation](https://reactjs.org/docs/hooks-effect.html).

Congratulations! What we've done up until here prepares how the Kitty object and other storage items will be accessible to our React components.

### Create the `KittyAvatar.js` component

In this component, all we're doing is mapping a library of PNG images to the bytes of our Kitty DNA. Since it's mostly all Javascript, 
we won't be going into much detail. 

Create a file in `src/` called `KittyAvatar.js` and paste in the following code:

```js
import React from 'react';

// Generate an array [start, start + 1, ..., end] inclusively
const genArray = (start, end) =>
  Array.from(Array(end - start + 1).keys()).map(v => v + start);

const IMAGES = {
  accessory: genArray(1, 20).map(n =>
    `${process.env.PUBLIC_URL}/assets/KittyAvatar/accessorie_${n}.png`),
  body: genArray(1, 15).map(n =>
    `${process.env.PUBLIC_URL}/assets/KittyAvatar/body_${n}.png`),
  eyes: genArray(1, 15).map(n =>
    `${process.env.PUBLIC_URL}/assets/KittyAvatar/eyes_${n}.png`),
  mouth: genArray(1, 10).map(n =>
    `${process.env.PUBLIC_URL}/assets/KittyAvatar/mouth_${n}.png`),
  fur: genArray(1, 10).map(n =>
    `${process.env.PUBLIC_URL}/assets/KittyAvatar/fur_${n}.png`)
};

const dnaToAttributes = dna => {
  const attribute = (index, type) => IMAGES[type][dna[index] % IMAGES[type].length];

  return {
    body: attribute(0, 'body'),
    eyes: attribute(1, 'eyes'),
    accessory: attribute(2, 'accessory'),
    fur: attribute(3, 'fur'),
    mouth: attribute(4, 'mouth')
  };
};

const KittyAvatar = props => {
  const outerStyle = { height: '160px', position: 'relative', width: '50%' };
  const innerStyle = { height: '150px', position: 'absolute', top: '3%', left: '50%' };
  const { dna } = props;

  if (!dna) return null;

  const cat = dnaToAttributes(dna);
  return <div style={outerStyle}>
    <img alt='body' src={cat.body} style={innerStyle} />
    <img alt='fur' src={cat.fur} style={innerStyle} />
    <img alt='mouth' src={cat.mouth} style={innerStyle} />
    <img alt='eyes' src={cat.eyes} style={innerStyle} />
    <img alt='accessory' src={cat.accessory} style={innerStyle} />
  </div>;
};

export default KittyAvatar;
```

Notice that the only properties being passed is `dna`, which will be passed in from `KittyCards.js`.
The logic in this component is based on a specific ["cat avatar generator" library](https://framagit.org/Deevad/cat-avatar-generator/-/tree/master/avatars/cat) by David Revoy. Download it and paste its contents inside a new folder called
"KittyAvatar" in `public/assets/KittyAvatar`.

### Create the `TransferModal` in `KittyCards.js`

Our `KittyCards.js` component will have three sections to it:

i. `TransferModal`: a modal that uses the `TxButton` component. 

ii. `KittyCard`: a card that renders the Kitty avatar using the `KittyAvatar.js` component as well as all other Kitty information (id, dna, owner, gender and price).

iii. `KittyCards`: a component that renders a grid for `KittyCard` (yes, singular!) described above. 

As a preliminary step, create a new file called `KittyCards.js` and add the following imports:

```js
import React from 'react';
import { Button, Card, Grid, Message, Modal, Form, Label } from 'semantic-ui-react';

import KittyAvatar from './KittyAvatar'; 
import { TxButton } from './substrate-lib/components';
```

#### i. Outlining the TransferModal

Let's outline what the `TransferModal` will do. Conveniently, the Substrate Front-end Template comes with a component called `TxButton` which is a useful way to include a transfer button 
that interacts with a node. This component will allow us to make an RPC call
into our node and trigger a signed extrinsic for the Kitties pallet. 

The way it is built can be broken down into the following pieces:

- A "transfer" button exists, which upon being clicked opens up a modal
- This modal, we'll call "Kitty Transfer" is a `Form` containing (1) the Kitty ID and (2) an input field for a receiving adress
- It also contains a "transfer" and "cancel" button 

See the screenshot taken below for reference: 

![Kitty Transfer](kitty-transfer-shot.png)

1.  Setting up React hooks

The first thing we'll do is pass in the properties (or "props") we need from `kitty`, `accountPair` and `setStatus` using React hooks. Do this by pasting in the following code snippet:

```js
const TransferModal = props => {
  const { kitty, accountPair, setStatus } = props;
  const [open, setOpen] = React.useState(false);
  const [formValue, setFormValue] = React.useState({});

  const formChange = key => (ev, el) => {
    setFormValue({ ...formValue, [key]: el.value });
  };
```
And now, close the React hook subscription function:

```js
  const confirmAndClose = (unsub) => {
    unsub();
    setOpen(false);
  };
```

2. Composing the modal

To recap: our Kitty Card has a "transfer" button that opens up a 
modal where a user can choose an address to send their Kitty to. That modal will have:
- a Title
- an input field for a Kitty ID
- an input field for an Account ID

In addition, it will have:
- a "cancel" button which closes the Transfer modal
- the `TxButton` React component to trigger the transaction

Here's what this looks like in code &mdash; paste this in to complete `TransferModal` and read the comments to follow what each
chunk of code is doing:

```js
return <Modal onClose={() => setOpen(false)} onOpen={() => setOpen(true)} open={open}
    trigger={<Button basic color='blue'>Transfer</Button>}>

    // The title of the modal
    <Modal.Header>Kitty Transfer</Modal.Header>

    <Modal.Content><Form>
    // The modal's inputs fields
      <Form.Input fluid label='Kitty ID' readOnly value={kitty.id}/>
      <Form.Input fluid label='Receiver' placeholder='Receiver Address' onChange={formChange('target')}/>
    </Form></Modal.Content>

    <Modal.Actions>
      // The cancel button
      <Button basic color='grey' onClick={() => setOpen(false)}>Cancel</Button>
      // The TxButton component
      <TxButton
        accountPair={accountPair} label='Transfer' type='SIGNED-TX' setStatus={setStatus}
        onClick={confirmAndClose}
        attrs={{
          palletRpc: 'kitties',
          callable: 'transfer',
          inputParams: [formValue.target, kitty.id],
          paramFields: [true, true]
        }}
      />
    </Modal.Actions>
  </Modal>;
```

The next part of our `KittyCards.js` component is to create the part that renders the `KittyAvatar.js` component and the data passed in from the `kitties` props in `Kitty.js`.

### Create the `KittyCard` in `KittyCards.js`

We'll use React's `Card` component to create a card that render the Kitty avatar as well as the Kitty ID, DNA, gender, owner and price.

As you might have guessed, we'll use React props to pass in data to our KittyCard. Paste the following code snippet, reading through the comments to understand each code snippet:

```js
// Use props
const KittyCard = props => {
  const { kitty, accountPair, setStatus } = props;
  const { id = null, dna = null, owner = null, gender = null, price = null } = kitty;
  const displayDna = dna && dna.toJSON();
  const isSelf = accountPair.address === kitty.owner;
```

Now let's make use of the previously imported `Card` component:

```js
return <Card>
    { isSelf && <Label as='a' floating color='teal'>Mine</Label> }
    // Render the Kitty Avatar
    <KittyAvatar dna={dna.toU8a()} />
    <Card.Content>
    // Display the Kitty ID
      <Card.Header style={{ fontSize: '1em', overflowWrap: 'break-word' }}>
        ID: {id}
      </Card.Header>
      // Display the Kitty DNA
      <Card.Meta style={{ fontSize: '.9em', overflowWrap: 'break-word' }}>
        DNA: {displayDna}
      </Card.Meta>
      // Display the Kitty ID, Gender, Owner and Price
      <Card.Description>
        <p style={{ overflowWrap: 'break-word' }}>
          Gender: {gender}
        </p>
        <p style={{ overflowWrap: 'break-word' }}>
          Owner: {owner}
        </p>
        <p style={{ overflowWrap: 'break-word' }}>
          Price: {price}
        </p>
      </Card.Description>
    </Card.Content>
```

Before closing the `<Card/>` component we want to render the `TransferModal` we privously built &mdash; **only if the Kitty is transferrable by the acitve user account**. Paste this code snippet to handle this functionality:

```js
    // Render the transfer button using TransferModal
    <Card.Content extra style={{ textAlign: 'center' }}>{ owner === accountPair.address
      ? <TransferModal kitty={kitty} accountPair={accountPair} setStatus={setStatus}/>
      : ''
    }</Card.Content>
  </Card>;
```

#### Rendering the card

It's time to put all the pieces we've built together. In this function, we'll: 
- Check whether there's any Kitties to render and render a _"No Kitty found here... Create one now!"_ message if there aren't any
- If there are, render them in a 3 column grid

Have a look at the comments to understand the parts of this code snippet:

```js
const KittyCards = props => {
  const { kitties, accountPair, setStatus } = props;

// Check the number of Kitties
  if (kitties.length === 0) {
    return <Message info>
      <Message.Header>No Kitty found here... Create one now!&nbsp;
        <span role='img' aria-label='point-down'>ðŸ‘‡</span>
      </Message.Header>
    </Message>;
  }
// Render Kitties using Kitty Card in a grid
  return <Grid columns={3}>{kitties.map((kitty, i) =>
    <Grid.Column key={`kitty-${i}`}>
      <KittyCard kitty={kitty} accountPair={accountPair} setStatus={setStatus}/>
    </Grid.Column>
  )}</Grid>;
};
```

And complete the component with:

```js
export default KittyCards;
```

### Complete `Kitties.js`

Now that we've built all the bits for our front-end application, we can piece everything together.

Go back to the incompleted `Kitties.js` file and paste this code snippet to render the `KittyCard.js` component inside a `<Grid/>`:

```js
return <Grid.Column width={16}>
    <h1>Kitties</h1>
    <KittyCards kitties={kitties} accountPair={accountPair} setStatus={setStatus}/>
```

Now we'll use the `<Form/>` component to render our application's `TxButton` component: 

```js
    <Form style={{ margin: '1em 0' }}>
      <Form.Field style={{ textAlign: 'center' }}>
        <TxButton
          accountPair={accountPair} label='Create Kitty' type='SIGNED-TX' setStatus={setStatus}
          attrs={{
            palletRpc: 'kitties',
            callable: 'createKitty',
            inputParams: [],
            paramFields: []
          }}
        />
      </Form.Field>
    </Form>
    <div style={{ overflowWrap: 'break-word' }}>{status}</div>
  </Grid.Column>;
```

### Update App.js

In order to render Kitties.js, we need to as a row item to the `<Container/>` in App.js:

```js
<Grid.Row>
    <Kitties accountPair={accountPair} />
</Grid.Row>
```

Congratulations! You've finsished the front-end turorial! Now run `yarn start`, refresh your browser and you should be able to start interacting with your node.

## Next steps 

- Explore the Polkadot JS API [cookbook](https://polkadot.js.org/docs/api/cookbook) 